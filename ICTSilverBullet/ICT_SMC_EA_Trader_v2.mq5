//+------------------------------------------------------------------+
//|                                            ICT_SMC_EA_v2.mq5     |
//|                        Automatisation des concepts ICT & SMC    |
//|                              Version Corrigée                    |
//+------------------------------------------------------------------+
#property copyright "Generated by AI"
#property link      ""
#property version   "2.00"
#property strict

#include <Trade\Trade.mqh>

//--- Paramètres d'entrée (Inputs)
input group "=== GESTION DU RISQUE ==="
input double   InpLotSize = 0.1;          // Taille du Lot
input int      InpStopLoss = 500;         // Stop Loss (en points)
input int      InpTakeProfit = 1000;      // Take Profit (en points)
input int      InpMagicNum = 123456;      // Magic Number

input group "=== KILL ZONES (HEURES SERVEUR) ==="
input bool     UseAsianKZ = false;        // Activer Kill Zone Asie
input int      AsianStart = 0;            // Début Asie (ex: 00:00)
input int      AsianEnd = 6;              // Fin Asie (ex: 06:00)

input bool     UseLondonKZ = true;        // Activer Kill Zone Londres
input int      LondonStart = 7;           // Début Londres (ex: 07:00 ou 08:00)
input int      LondonEnd = 10;            // Fin Londres (ex: 10:00)

input bool     UseNYKZ = true;            // Activer Kill Zone New York
input int      NYStart = 12;              // Début NY (ex: 12:00 ou 13:00)
input int      NYEnd = 15;                // Fin NY (ex: 15:00)

input group "=== CONCEPTS ICT & SMC ==="
input int      LookBackBars = 200;        // Nombre de bougies pour l'analyse
input double   FVG_MinSize = 0.0005;      // Taille min du FVG (en prix brut)
input int      StructureLookback = 20;    // Périodes pour valider un Break of Structure

//--- Variables globales
CTrade trade;
datetime lastTradeTime = 0;

//+------------------------------------------------------------------+
//| Fonction d'initialisation de l'EA                                |
//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber(InpMagicNum);
   Print("ICT/SMC EA v2 Initialisé avec succès.");
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Fonction de désinitialisation                                    |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   Print("ICT/SMC EA Arrêté.");
  }
//+------------------------------------------------------------------+
//| Fonction principale appelée à chaque tick                       |
//+------------------------------------------------------------------+
void OnTick()
  {
   // 1. Vérification si une position est déjà ouverte (Pour cet exemple, 1 trade max)
   if(PositionsTotal() > 0) return;

   // 2. Vérification des Kill Zones (Temps)
   if(!IsKillZoneActive()) return;

   // 3. Vérification du Nouveau Bar (Pour éviter de re-calculer à chaque tick)
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
   if(lastBarTime == currentBarTime) return;
   lastBarTime = currentBarTime;

   // 4. Analyse des Concepts
   double fvgHigh, fvgLow;
   bool isBullishFVG = DetectFVG(fvgHigh, fvgLow, true);  // Détecte FVG Haussier
   bool isBearishFVG = DetectFVG(fvgHigh, fvgLow, false); // Détecte FVG Baissier

   // Stratégie Long
   if(isBullishFVG)
     {
      // Vérification du Market Structure (Bullish Break of Structure)
      if(CheckBullishStructure())
        {
         // Vérification si le prix revient dans le FVG (Discount/Entry)
         double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         if(ask >= fvgLow && ask <= fvgHigh)
           {
            ExecuteTrade(ORDER_TYPE_BUY, ask, InpStopLoss, InpTakeProfit, "ICT Long FVG");
           }
        }
     }

   // Stratégie Short
   if(isBearishFVG)
     {
      // Vérification du Market Structure (Bearish Break of Structure)
      if(CheckBearishStructure())
        {
         // Vérification si le prix revient dans le FVG (Premium/Entry)
         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         if(bid <= fvgHigh && bid >= fvgLow)
           {
            ExecuteTrade(ORDER_TYPE_SELL, bid, InpStopLoss, InpTakeProfit, "ICT Short FVG");
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| DÉTECTION DES KILL ZONES                                          |
//+------------------------------------------------------------------+
bool IsKillZoneActive()
  {
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   int hour = dt.hour;

   // Asie
   if(UseAsianKZ && hour >= AsianStart && hour < AsianEnd) return true;
   // Londres
   if(UseLondonKZ && hour >= LondonStart && hour < LondonEnd) return true;
   // New York
   if(UseNYKZ && hour >= NYStart && hour < NYEnd) return true;

   return false;
  }

//+------------------------------------------------------------------+
//| DÉTECTION DES FAIR VALUE GAPS (FVG) - CORRIGÉ                    |
//+------------------------------------------------------------------+
bool DetectFVG(double &high, double &low, bool bullish)
  {
   // On parcourt les dernières bougies pour trouver un FVG
   // Un FVG Haussier : Bougie i+1 High > Bougie i+3 Low (Gap entre 1 et 3)
   // Un FVG Baissier : Bougie i+1 Low < Bougie i+3 High

   for(int i = 1; i < StructureLookback; i++)
     {
      double bar1_high = iHigh(_Symbol, PERIOD_CURRENT, i+1);
      double bar1_low = iLow(_Symbol, PERIOD_CURRENT, i+1);
      
      double bar3_high = iHigh(_Symbol, PERIOD_CURRENT, i+3);
      double bar3_low = iLow(_Symbol, PERIOD_CURRENT, i+3); // CORRECTION ICI (était PERMIT_CURRENT)

      if(bullish)
        {
         // Vérification FVG Haussier (Imbalance)
         if(bar1_low > bar3_high)
           {
            double gapSize = bar1_low - bar3_high;
            if(gapSize >= FVG_MinSize)
              {
               high = bar1_low;  // Plafond du FVG
               low = bar3_high;  // Plancher du FVG
               return true;
              }
           }
        }
      else // Bearish
        {
         // Vérification FVG Baissier
         if(bar1_high < bar3_low)
           {
            double gapSize = bar3_low - bar1_high;
            if(gapSize >= FVG_MinSize)
              {
               high = bar3_low;   // Plafond du FVG
               low = bar1_high;   // Plancher du FVG
               return true;
              }
           }
        }
     }
   return false;
  }

//+------------------------------------------------------------------+
//| VÉRIFICATION DU MARKET STRUCTURE (Break of Structure)            |
//+------------------------------------------------------------------+
bool CheckBullishStructure()
  {
   // Logique simplifiée : Cherche un Swing High qui a été cassé à la hausse récemment
   double currentHigh = iHigh(_Symbol, PERIOD_CURRENT, 1);
   
   // On cherche le plus haut récent significatif
   double recentSwingHigh = 0;
   int swingIndex = -1;
   
   for(int i = 2; i < StructureLookback; i++)
     {
      double high = iHigh(_Symbol, PERIOD_CURRENT, i);
      // Très basique : si on trouve un haut plus grand que les 5 barres suivantes
      if(high > iHigh(_Symbol, PERIOD_CURRENT, i+1) && high > iHigh(_Symbol, PERIOD_CURRENT, i+2) &&
         high > iHigh(_Symbol, PERIOD_CURRENT, i+3) && high > iHigh(_Symbol, PERIOD_CURRENT, i+4))
        {
         recentSwingHigh = high;
         swingIndex = i;
         break;
        }
     }

   // Si un Swing High a été trouvé et que le prix actuel l'a cassé
   if(recentSwingHigh > 0 && currentHigh > recentSwingHigh)
     {
      return true; // Bullish BoS confirmé
     }

   return false;
  }

bool CheckBearishStructure()
  {
   // Logique inverse : Cherche un Swing Low cassé à la baisse
   double currentLow = iLow(_Symbol, PERIOD_CURRENT, 1);
   
   double recentSwingLow = 999999;
   
   for(int i = 2; i < StructureLookback; i++)
     {
      double low = iLow(_Symbol, PERIOD_CURRENT, i);
      if(low < iLow(_Symbol, PERIOD_CURRENT, i+1) && low < iLow(_Symbol, PERIOD_CURRENT, i+2) &&
         low < iLow(_Symbol, PERIOD_CURRENT, i+3) && low < iLow(_Symbol, PERIOD_CURRENT, i+4)) // CORRECTION ICI (était PERBIT_CURRENT)
        {
         recentSwingLow = low;
         break;
        }
     }

   if(recentSwingLow < 999999 && currentLow < recentSwingLow)
     {
      return true; // Bearish BoS confirmé
     }
   return false;
  }

//+------------------------------------------------------------------+
//| EXÉCUTION DES ORDRES                                              |
//+------------------------------------------------------------------+
void ExecuteTrade(ENUM_ORDER_TYPE orderType, double price, int sl, int tp, string comment)
  {
   double slPrice, tpPrice;
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   if(orderType == ORDER_TYPE_BUY)
     {
      slPrice = price - (sl * point);
      tpPrice = price + (tp * point);
      if(!trade.Buy(InpLotSize, _Symbol, price, slPrice, tpPrice, comment))
         Print("Erreur Achat : ", GetLastError());
     }
   else if(orderType == ORDER_TYPE_SELL)
     {
      slPrice = price + (sl * point);
      tpPrice = price - (tp * point);
      if(!trade.Sell(InpLotSize, _Symbol, price, slPrice, tpPrice, comment))
         Print("Erreur Vente : ", GetLastError());
     }
   }
//+------------------------------------------------------------------+
