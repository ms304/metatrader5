//+------------------------------------------------------------------+
//|                                            ICT_SMC_EA_v3.mq5     |
//|                        Automatisation des concepts ICT & SMC    |
//|                              Version Debug & Backtest            |
//+------------------------------------------------------------------+
#property copyright "Generated by AI"
#property link      ""
#property version   "3.00"
#property strict

#include <Trade\Trade.mqh>

//--- Paramètres d'entrée (Inputs)
input group "=== GESTION DU RISQUE ==="
input double   InpLotSize = 0.1;          // Taille du Lot
input int      InpStopLoss = 500;         // Stop Loss (en points)
input int      InpTakeProfit = 1000;      // Take Profit (en points)
input int      InpMagicNum = 123456;      // Magic Number

input group "=== KILL ZONES (HEURES SERVEUR) ==="
input bool     UseAsianKZ = false;        // Activer Kill Zone Asie
input int      AsianStart = 0;            // Début Asie (ex: 00:00)
input int      AsianEnd = 6;              // Fin Asie (ex: 06:00)

input bool     UseLondonKZ = true;        // Activer Kill Zone Londres
input int      LondonStart = 7;           // Début Londres (ex: 07:00 ou 08:00)
input int      LondonEnd = 10;            // Fin Londres (ex: 10:00)

input bool     UseNYKZ = true;            // Activer Kill Zone New York
input int      NYStart = 12;              // Début NY (ex: 12:00 ou 13:00)
input int      NYEnd = 15;                // Fin NY (ex: 15:00)

input group "=== CONCEPTS ICT & SMC ==="
input int      LookBackBars = 200;        // Nombre de bougies pour l'analyse
input double   FVG_MinSize = 0.0001;      // Taille min du FVG (RÉDUIT pour le test)
input int      StructureLookback = 20;    // Périodes pour valider un Break of Structure

input group "=== DEBUG & OPTIONS ==="
input bool     UseStrictStructure = true; // Si false, ignore le BoS (plus de trades)

//--- Variables globales
CTrade trade;
datetime lastTradeTime = 0;

//+------------------------------------------------------------------+
//| Fonction d'initialisation de l'EA                                |
//+------------------------------------------------------------------+
int OnInit()
  {
   trade.SetExpertMagicNumber(InpMagicNum);
   Print("ICT/SMC EA v3 Initialisé. Mode Backtest Actif.");
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Fonction de désinitialisation                                    |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   Print("ICT/SMC EA Arrêté.");
  }
//+------------------------------------------------------------------+
//| Fonction principale appelée à chaque tick                       |
//+------------------------------------------------------------------+
void OnTick()
  {
   // 1. Vérification si une position est déjà ouverte
   if(PositionsTotal() > 0) return;

   // 2. Vérification des Kill Zones (Temps) avec Debug
   bool kzActive = IsKillZoneActive();
   
   // DEBUG : Affiche l'heure et le statut KZ toutes les heures pour voir si ça tourne
   static int lastHourPrinted = -1;
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   if(dt.hour != lastHourPrinted)
     {
      Print("--- HEURE SERVEUR : ", dt.hour, ":00 | Kill Zone : ", kzActive ? "OUI" : "NON");
      lastHourPrinted = dt.hour;
     }

   if(!kzActive) return;

   // 3. NOTE: Nous avons retiré le filtre "Nouveau Bar" pour le backtest.
   // L'EA analyse maintenant en continu pour ne pas rater les entrées rapides.

   // 4. Analyse des Concepts
   double fvgHigh, fvgLow;
   bool isBullishFVG = DetectFVG(fvgHigh, fvgLow, true);
   bool isBearishFVG = DetectFVG(fvgHigh, fvgLow, false);

   // Stratégie Long
   if(isBullishFVG)
     {
      // Vérification du Market Structure (ou bypass si activé)
      bool structOK = UseStrictStructure ? CheckBullishStructure() : true;
      
      if(structOK)
        {
         double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         if(ask >= fvgLow && ask <= fvgHigh)
           {
            Print(">>> SIGNAL LONG DÉTECTÉ : Prix dans FVG Haussier");
            ExecuteTrade(ORDER_TYPE_BUY, ask, InpStopLoss, InpTakeProfit, "ICT Long FVG");
           }
        }
     }

   // Stratégie Short
   if(isBearishFVG)
     {
      bool structOK = UseStrictStructure ? CheckBearishStructure() : true;
      
      if(structOK)
        {
         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         if(bid <= fvgHigh && bid >= fvgLow)
           {
            Print(">>> SIGNAL SHORT DÉTECTÉ : Prix dans FVG Baissier");
            ExecuteTrade(ORDER_TYPE_SELL, bid, InpStopLoss, InpTakeProfit, "ICT Short FVG");
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| DÉTECTION DES KILL ZONES                                          |
//+------------------------------------------------------------------+
bool IsKillZoneActive()
  {
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   int hour = dt.hour;

   if(UseAsianKZ && hour >= AsianStart && hour < AsianEnd) return true;
   if(UseLondonKZ && hour >= LondonStart && hour < LondonEnd) return true;
   if(UseNYKZ && hour >= NYStart && hour < NYEnd) return true;

   return false;
  }

//+------------------------------------------------------------------+
//| DÉTECTION DES FAIR VALUE GAPS (FVG)                               |
//+------------------------------------------------------------------+
bool DetectFVG(double &high, double &low, bool bullish)
  {
   // Recherche des 50 dernières bougies pour trouver un FVG
   int lookBack = 50; 
  
   for(int i = 1; i < lookBack; i++)
     {
      // Attention: Dans un test rapide, on peut accéder aux indices qui n'existent pas si i+3 est trop loin
      if(i + 3 >= Bars(_Symbol, PERIOD_CURRENT)) break;

      double bar1_high = iHigh(_Symbol, PERIOD_CURRENT, i+1);
      double bar1_low = iLow(_Symbol, PERIOD_CURRENT, i+1);
      
      double bar3_high = iHigh(_Symbol, PERIOD_CURRENT, i+3);
      double bar3_low = iLow(_Symbol, PERIOD_CURRENT, i+3);

      if(bullish)
        {
         // FVG Haussier : Bougie 1 Low > Bougie 3 High
         if(bar1_low > bar3_high)
           {
            double gapSize = bar1_low - bar3_high;
            if(gapSize >= FVG_MinSize)
              {
               high = bar1_low;
               low = bar3_high;
               return true;
              }
           }
        }
      else // Bearish
        {
         // FVG Baissier : Bougie 1 High < Bougie 3 Low
         if(bar1_high < bar3_low)
           {
            double gapSize = bar3_low - bar1_high;
            if(gapSize >= FVG_MinSize)
              {
               high = bar3_low;
               low = bar1_high;
               return true;
              }
           }
        }
     }
   return false;
  }

//+------------------------------------------------------------------+
//| VÉRIFICATION DU MARKET STRUCTURE (Break of Structure)            |
//+------------------------------------------------------------------+
bool CheckBullishStructure()
  {
   double currentHigh = iHigh(_Symbol, PERIOD_CURRENT, 1);
   double recentSwingHigh = 0;
   
   for(int i = 2; i < StructureLookback; i++)
     {
      double high = iHigh(_Symbol, PERIOD_CURRENT, i);
      // Recherche simple d'un Swing High
      if(high > iHigh(_Symbol, PERIOD_CURRENT, i+1) && high > iHigh(_Symbol, PERIOD_CURRENT, i+2) &&
         high > iHigh(_Symbol, PERIOD_CURRENT, i+3) && high > iHigh(_Symbol, PERIOD_CURRENT, i+4))
        {
         recentSwingHigh = high;
         break;
        }
     }

   if(recentSwingHigh > 0 && currentHigh > recentSwingHigh)
     return true; // BoS confirmé

   return false;
  }

bool CheckBearishStructure()
  {
   double currentLow = iLow(_Symbol, PERIOD_CURRENT, 1);
   double recentSwingLow = 999999;
   
   for(int i = 2; i < StructureLookback; i++)
     {
      double low = iLow(_Symbol, PERIOD_CURRENT, i);
      if(low < iLow(_Symbol, PERIOD_CURRENT, i+1) && low < iLow(_Symbol, PERIOD_CURRENT, i+2) &&
         low < iLow(_Symbol, PERIOD_CURRENT, i+3) && low < iLow(_Symbol, PERIOD_CURRENT, i+4))
        {
         recentSwingLow = low;
         break;
        }
     }

   if(recentSwingLow < 999999 && currentLow < recentSwingLow)
     return true;

   return false;
  }

//+------------------------------------------------------------------+
//| EXÉCUTION DES ORDRES                                              |
//+------------------------------------------------------------------+
void ExecuteTrade(ENUM_ORDER_TYPE orderType, double price, int sl, int tp, string comment)
  {
   double slPrice, tpPrice;
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   if(orderType == ORDER_TYPE_BUY)
     {
      slPrice = price - (sl * point);
      tpPrice = price + (tp * point);
      if(!trade.Buy(InpLotSize, _Symbol, price, slPrice, tpPrice, comment))
         Print("Erreur Achat : ", GetLastError());
     }
   else if(orderType == ORDER_TYPE_SELL)
     {
      slPrice = price + (sl * point);
      tpPrice = price - (tp * point);
      if(!trade.Sell(InpLotSize, _Symbol, price, slPrice, tpPrice, comment))
         Print("Erreur Vente : ", GetLastError());
     }
   }
//+------------------------------------------------------------------+
